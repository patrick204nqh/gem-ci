# ğŸ“‹ Workflow: Code Quality & Analysis
# ğŸ¯ Purpose: Code linting, RuboCop analysis, documentation generation
# ğŸ”„ Triggers: Push/PR to main/master branches
# ğŸ“¦ Outputs: Quality reports, documentation, complexity analysis
# â±ï¸ Duration: ~6-12 minutes
# ğŸ”— Dependencies: GitHub App authentication

name: 04 - Quality

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

env:
  RUBY_VERSION: "3.3"
  NODE_VERSION: "20"
  CACHE_VERSION: "v1"
  DEFAULT_TIMEOUT: "300"
  API_RETRY_COUNT: "3"

jobs:
  linting:
    name: ğŸ” Code Linting
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      checks: write
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ”‘ Generate GitHub App Token
        id: app_token
        uses: ./.github/actions/github-app-token
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.PRIVATE_KEY }}

      - name: ğŸ’ Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: ${{ env.RUBY_VERSION }}
          bundler-cache: true

      - name: ğŸ” Non-Ruby Code Linting
        run: |
          echo "ğŸ” Running non-Ruby linting checks..."
          
          # YAML validation
          echo "ğŸ“„ YAML files:"
          find . -name "*.yml" -o -name "*.yaml" | grep -v vendor | head -10 | while read file; do
            echo "  Checking: $file"
            ruby -e "require 'yaml'; YAML.load_file('$file')" 2>/dev/null && echo "    âœ… Valid" || echo "    âŒ Invalid"
          done
          
          # JSON validation
          echo "ğŸ“‹ JSON files:"
          find . -name "*.json" | grep -v vendor | head -5 | while read file; do
            echo "  Checking: $file"
            ruby -e "require 'json'; JSON.parse(File.read('$file'))" 2>/dev/null && echo "    âœ… Valid" || echo "    âŒ Invalid"
          done
          
          # Markdown basic check
          echo "ğŸ“ Markdown files:"
          find . -name "*.md" | grep -v vendor | head -5 | while read file; do
            echo "  Checking: $file"
            [ -f "$file" ] && echo "    âœ… Exists" || echo "    âŒ Missing"
          done
          
          echo "âœ… Non-Ruby linting complete"

  rubocop:
    name: ğŸ’ RuboCop Analysis
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      checks: write
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ”‘ Generate GitHub App Token
        id: app_token
        uses: ./.github/actions/github-app-token
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.PRIVATE_KEY }}

      - name: ğŸ’ Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: ${{ env.RUBY_VERSION }}
          bundler-cache: true

      - name: ğŸ” Run RuboCop
        run: |
          bundle exec rubocop --format github --format json --out rubocop-results.json
        continue-on-error: true

      - name: ğŸ“Š RuboCop Report
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request'
        with:
          github-token: ${{ steps.app_token.outputs.token }}
          script: |
            const fs = require('fs');
            
            try {
              const results = JSON.parse(fs.readFileSync('rubocop-results.json', 'utf8'));
              const { files, summary } = results;
              
              let reportBody = `## ğŸ’ RuboCop Analysis Results\n\n`;
              reportBody += `**Files Inspected**: ${summary.inspected_file_count}\n`;
              reportBody += `**Offenses**: ${summary.offense_count}\n`;
              reportBody += `**Target Version**: ${summary.target_ruby_version}\n\n`;
              
              if (summary.offense_count === 0) {
                reportBody += `ğŸ‰ **Excellent!** No RuboCop offenses found.\n`;
              } else {
                reportBody += `### ğŸ“‹ Issues Found\n\n`;
                
                const issueFiles = files.filter(file => file.offenses.length > 0);
                issueFiles.slice(0, 5).forEach(file => {
                  reportBody += `**ğŸ“„ ${file.path}**\n`;
                  file.offenses.slice(0, 3).forEach(offense => {
                    reportBody += `- Line ${offense.location.start_line}: ${offense.message} (${offense.cop_name})\n`;
                  });
                  if (file.offenses.length > 3) {
                    reportBody += `- ... and ${file.offenses.length - 3} more issues\n`;
                  }
                  reportBody += `\n`;
                });
                
                if (issueFiles.length > 5) {
                  reportBody += `... and ${issueFiles.length - 5} more files with issues\n\n`;
                }
              }
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: reportBody
              });
            } catch (error) {
              console.log('Could not parse RuboCop results:', error.message);
            }

  documentation:
    name: ğŸ“š Documentation Generation
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pages: write
      id-token: write
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ”‘ Generate GitHub App Token
        id: app_token
        uses: ./.github/actions/github-app-token
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.PRIVATE_KEY }}

      - name: ğŸ’ Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: ${{ env.RUBY_VERSION }}
          bundler-cache: true

      - name: ğŸ“š Generate YARD documentation
        run: |
          bundle exec yard doc --output-dir docs/_site
          
          # Add custom styling and index
          cat > docs/_site/index.html << 'EOF'
          <!DOCTYPE html>
          <html>
          <head>
            <title>gem-ci Documentation</title>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
              body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 2rem; }
              .header { text-align: center; margin-bottom: 2rem; }
              .links { display: flex; justify-content: center; gap: 2rem; flex-wrap: wrap; }
              .link { padding: 1rem 2rem; background: #f6f8fa; border-radius: 6px; text-decoration: none; color: #24292f; }
              .link:hover { background: #e7eaf0; }
            </style>
          </head>
          <body>
            <div class="header">
              <h1>ğŸ† gem-ci Documentation</h1>
              <p>Comprehensive OSS automation showcase with battle-tested GitHub Actions</p>
            </div>
            <div class="links">
              <a href="Gem.html" class="link">ğŸ“¦ API Documentation</a>
              <a href="../README.md" class="link">ğŸ“– README</a>
              <a href="../COMPREHENSIVE_AUTOMATION_PLAN.md" class="link">ğŸ¯ Automation Plan</a>
            </div>
          </body>
          </html>
          EOF

      - name: ğŸ“¤ Upload documentation artifacts
        uses: actions/upload-artifact@v4
        with:
          name: documentation
          path: docs/_site/
          retention-days: 30

      - name: ğŸš€ Deploy to GitHub Pages
        if: github.ref == format('refs/heads/{0}', github.event.repository.default_branch)
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ steps.app_token.outputs.token }}
          publish_dir: ./docs/_site
          destination_dir: .
          keep_files: false
          commit_message: 'ğŸ“š Deploy documentation [skip ci]'

  complexity-analysis:
    name: ğŸ“Š Code Complexity Analysis
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ”‘ Generate GitHub App Token
        id: app_token
        uses: ./.github/actions/github-app-token
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.PRIVATE_KEY }}

      - name: ğŸ’ Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: ${{ env.RUBY_VERSION }}
          bundler-cache: true

      - name: ğŸ“Š Analyze code complexity
        run: |
          # Install flog for complexity analysis
          gem install flog
          
          # Run complexity analysis
          echo "## ğŸ“Š Code Complexity Analysis" > complexity-report.md
          echo "" >> complexity-report.md
          
          if find . -name "*.rb" -not -path "./vendor/*" | head -1 | read; then
            echo "### ğŸ¯ Complexity Scores (Lower is Better)" >> complexity-report.md
            echo "" >> complexity-report.md
            flog lib/ | head -20 >> complexity-report.md || echo "No complexity issues found!" >> complexity-report.md
            echo "" >> complexity-report.md
            echo "**Note**: Flog scores above 40 indicate high complexity that may need refactoring." >> complexity-report.md
          else
            echo "No Ruby files found for analysis." >> complexity-report.md
          fi

      - name: ğŸ“ Comment complexity analysis
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request'
        with:
          github-token: ${{ steps.app_token.outputs.token }}
          script: |
            const fs = require('fs');
            
            try {
              const report = fs.readFileSync('complexity-report.md', 'utf8');
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: report
              });
            } catch (error) {
              console.log('Could not read complexity report:', error.message);
            }

  quality-summary:
    name: ğŸ“‹ Quality Gate Summary
    runs-on: ubuntu-latest
    needs: [linting, rubocop, documentation, complexity-analysis]
    if: always()
    permissions:
      contents: read
      pull-requests: write
      checks: write
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        
      - name: ğŸ“¢ Notify Quality Gate Status
        uses: ./.github/workflows/shared/notification
        with:
          message: "Quality Gate completed for ${{ github.ref_name }}"
          status: ${{ needs.linting.result == 'success' && needs.rubocop.result == 'success' && needs.documentation.result == 'success' && needs.complexity-analysis.result == 'success' && 'success' || 'failure' }}
          slack-bot-token: ${{ secrets.SLACK_BOT_TOKEN }}
          slack-channel-id: ${{ secrets.SLACK_CHANNEL_ID }}

      - name: ğŸ”‘ Generate GitHub App Token
        id: app_token
        uses: ./.github/actions/github-app-token
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.PRIVATE_KEY }}

      - name: ğŸ“Š Quality Gate Results
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app_token.outputs.token }}
          script: |
            const jobs = [
              { name: 'linting', result: '${{ needs.linting.result }}' },
              { name: 'rubocop', result: '${{ needs.rubocop.result }}' },
              { name: 'documentation', result: '${{ needs.documentation.result }}' },
              { name: 'complexity-analysis', result: '${{ needs.complexity-analysis.result }}' }
            ];
            
            const passed = jobs.filter(job => job.result === 'success').length;
            const failed = jobs.filter(job => job.result === 'failure').length;
            const total = jobs.length;
            
            const qualityGatePassed = failed === 0;
            
            const summary = `## ğŸ† Quality Gate Results
            
            **Status**: ${qualityGatePassed ? 'âœ… PASSED' : 'âŒ FAILED'}
            **Quality Score**: ${passed}/${total} checks passed
            
            ### ğŸ“Š Individual Results
            ${jobs.map(job => {
              const emoji = job.result === 'success' ? 'âœ…' : 
                           job.result === 'failure' ? 'âŒ' : 'â¸ï¸';
              return `- ${emoji} **${job.name}**: ${job.result}`;
            }).join('\n')}
            
            ${qualityGatePassed ? 
              'ğŸ‰ **Excellent work!** All quality checks passed.' : 
              'âš ï¸ **Action needed**: Please address the failing quality checks above.'
            }
            `;
            
            if (context.eventName === 'pull_request') {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: summary
              });
            }
            
            console.log(summary);
            
            // Set output for other workflows
            core.setOutput('quality-gate-passed', qualityGatePassed);
            core.setOutput('quality-score', `${passed}/${total}`);
