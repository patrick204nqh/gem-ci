name: Advanced Monitoring and Metrics

on:
  push:
    branches: [ $default-branch ]
  pull_request:
    branches: [ $default-branch ]
  schedule:
    # Run comprehensive monitoring daily at 4 AM UTC
    - cron: '0 4 * * *'
  workflow_dispatch:

env:
  RUBY_VERSION: "3.2"

jobs:
  workflow-metrics:
    name: üìà Workflow Performance Metrics
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      issues: write
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üìä Analyze workflow performance
        uses: actions/github-script@v6
        with:
          script: |
            const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
            
            // Get workflow runs for the last 30 days
            const { data: workflows } = await github.rest.actions.listRepoWorkflows({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            
            let performanceReport = `## üìä Workflow Performance Analysis
            **Period**: Last 30 days
            **Generated**: ${new Date().toISOString().split('T')[0]}
            
            ### üöÄ Workflow Statistics
            `;
            
            let totalRuns = 0;
            let successfulRuns = 0;
            let failedRuns = 0;
            let totalDuration = 0;
            let workflowStats = [];
            
            for (const workflow of workflows.workflows) {
              const { data: runs } = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: workflow.id,
                created: `>${thirtyDaysAgo.toISOString()}`,
                per_page: 100
              });
              
              const workflowSuccessful = runs.workflow_runs.filter(run => run.conclusion === 'success').length;
              const workflowFailed = runs.workflow_runs.filter(run => run.conclusion === 'failure').length;
              const workflowTotal = runs.workflow_runs.length;
              
              if (workflowTotal > 0) {
                const avgDuration = runs.workflow_runs
                  .filter(run => run.created_at && run.updated_at)
                  .reduce((sum, run) => {
                    const duration = new Date(run.updated_at) - new Date(run.created_at);
                    return sum + duration;
                  }, 0) / workflowTotal;
                
                workflowStats.push({
                  name: workflow.name,
                  total: workflowTotal,
                  successful: workflowSuccessful,
                  failed: workflowFailed,
                  avgDuration: Math.round(avgDuration / 1000 / 60) // minutes
                });
                
                totalRuns += workflowTotal;
                successfulRuns += workflowSuccessful;
                failedRuns += workflowFailed;
                totalDuration += avgDuration;
              }
            }
            
            // Calculate overall metrics
            const successRate = totalRuns > 0 ? Math.round((successfulRuns / totalRuns) * 100) : 0;
            const avgWorkflowDuration = workflowStats.length > 0 ? Math.round(totalDuration / workflowStats.length / 1000 / 60) : 0;
            
            performanceReport += `
            **üìà Overall Performance**
            - **Total Runs**: ${totalRuns}
            - **Success Rate**: ${successRate}%
            - **Failed Runs**: ${failedRuns}
            - **Average Duration**: ${avgWorkflowDuration} minutes
            
            ### üîç Workflow Breakdown
            `;
            
            workflowStats
              .sort((a, b) => b.total - a.total)
              .slice(0, 10)
              .forEach(stat => {
                const successRate = stat.total > 0 ? Math.round((stat.successful / stat.total) * 100) : 0;
                const statusEmoji = successRate >= 95 ? 'üü¢' : successRate >= 80 ? 'üü°' : 'üî¥';
                
                performanceReport += `
            **${statusEmoji} ${stat.name}**
            - Runs: ${stat.total} | Success: ${successRate}% | Avg Duration: ${stat.avgDuration}min`;
              });
            
            performanceReport += `
            
            ### üéØ Performance Insights
            ${successRate >= 95 ? 'üéâ **Excellent**: Workflow reliability is outstanding!' : 
              successRate >= 80 ? '‚ö†Ô∏è **Good**: Some workflows may need optimization.' : 
              'üö® **Attention**: Multiple workflows showing reliability issues.'}
            
            ${avgWorkflowDuration <= 10 ? '‚ö° **Fast**: Workflows are completing quickly.' :
              avgWorkflowDuration <= 20 ? '‚è∞ **Moderate**: Workflow duration is acceptable.' :
              'üêå **Slow**: Consider optimizing workflow performance.'}
            
            ### üìä Recommendations
            ${failedRuns > 10 ? '- Review failed workflows for common patterns' : '‚úÖ Low failure rate'}
            ${avgWorkflowDuration > 15 ? '- Consider parallelizing slow workflows' : '‚úÖ Good performance'}
            ${successRate < 90 ? '- Investigate reliability issues in failing workflows' : '‚úÖ High reliability'}
            
            *Generated by advanced monitoring workflow* ü§ñ
            `;
            
            console.log(performanceReport);
            
            // Store metrics as repository variables
            await github.rest.actions.setRepoVariable({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'WORKFLOW_SUCCESS_RATE',
              value: successRate.toString()
            });
            
            await github.rest.actions.setRepoVariable({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'WORKFLOW_AVG_DURATION',
              value: avgWorkflowDuration.toString()
            });

  action-usage-analysis:
    name: üîç GitHub Actions Usage Analysis
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîç Analyze action usage and reliability
        run: |
          echo "## üîç GitHub Actions Reliability Analysis" > action_analysis.md
          echo "**Generated**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> action_analysis.md
          echo "" >> action_analysis.md
          
          # Extract all actions from workflow files
          echo "### üìä Action Inventory" >> action_analysis.md
          echo "" >> action_analysis.md
          
          declare -A actions
          declare -A action_counts
          
          # Parse workflow files for action usage
          for workflow in .github/workflows/*.yml; do
            if [[ -f "$workflow" ]]; then
              while IFS= read -r line; do
                if [[ "$line" =~ uses:[:space:]*([^[:space:]@]+)@([^[:space:]]+) ]]; then
                  action="${BASH_REMATCH[1]}"
                  version="${BASH_REMATCH[2]}"
                  full_action="${action}@${version}"
                  
                  if [[ ! -z "$action" ]]; then
                    actions["$action"]="$version"
                    ((action_counts["$action"]++))
                  fi
                fi
              done < "$workflow"
            fi
          done
          
          # Categorize actions by source
          official_github=0
          official_orgs=0
          community_actions=0
          
          echo "| Action | Version | Usage Count | Category |" >> action_analysis.md
          echo "|--------|---------|-------------|----------|" >> action_analysis.md
          
          for action in "${!actions[@]}"; do
            version="${actions[$action]}"
            count="${action_counts[$action]}"
            
            # Categorize actions
            if [[ "$action" == actions/* ]]; then
              category="üèõÔ∏è Official GitHub"
              ((official_github++))
            elif [[ "$action" == ruby/* ]] || [[ "$action" == google-github-actions/* ]] || [[ "$action" == github/* ]]; then
              category="üè¢ Official Org"
              ((official_orgs++))
            else
              category="üë• Community"
              ((community_actions++))
            fi
            
            echo "| \`$action\` | $version | $count | $category |" >> action_analysis.md
          done
          
          total_actions=$((official_github + official_orgs + community_actions))
          official_percentage=$(( (official_github + official_orgs) * 100 / total_actions ))
          
          echo "" >> action_analysis.md
          echo "### üìà Reliability Metrics" >> action_analysis.md
          echo "" >> action_analysis.md
          echo "- **Total Unique Actions**: $total_actions" >> action_analysis.md
          echo "- **Official GitHub Actions**: $official_github" >> action_analysis.md
          echo "- **Official Organization Actions**: $official_orgs" >> action_analysis.md
          echo "- **Community Actions**: $community_actions" >> action_analysis.md
          echo "- **Official Action Percentage**: ${official_percentage}%" >> action_analysis.md
          echo "" >> action_analysis.md
          
          if [[ $official_percentage -ge 90 ]]; then
            echo "üéâ **Excellent**: ${official_percentage}% official actions provides maximum reliability!" >> action_analysis.md
          elif [[ $official_percentage -ge 70 ]]; then
            echo "‚úÖ **Good**: ${official_percentage}% official actions provides strong reliability." >> action_analysis.md
          else
            echo "‚ö†Ô∏è **Review**: Consider increasing official action usage for better reliability." >> action_analysis.md
          fi
          
          echo "" >> action_analysis.md
          echo "*Analysis generated by advanced monitoring workflow* ü§ñ" >> action_analysis.md

      - name: üìä Post action analysis
        uses: actions/github-script@v6
        if: github.event_name == 'schedule'
        with:
          script: |
            const fs = require('fs');
            const analysisContent = fs.readFileSync('action_analysis.md', 'utf8');
            
            // Look for existing analysis issue
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'monitoring,automated',
              state: 'open'
            });
            
            const existingIssue = issues.find(issue => 
              issue.title.includes('GitHub Actions Analysis')
            );
            
            const issueTitle = `üîç Weekly GitHub Actions Analysis - ${new Date().toISOString().split('T')[0]}`;
            
            if (existingIssue) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                title: issueTitle,
                body: analysisContent
              });
              console.log(`Updated existing analysis issue #${existingIssue.number}`);
            } else {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: issueTitle,
                body: analysisContent,
                labels: ['monitoring', 'automated', 'analysis']
              });
              console.log('Created new action analysis issue');
            }

  repository-health:
    name: üè• Repository Health Check
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: read
      pull-requests: read
      actions: write
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üè• Comprehensive repository health analysis
        uses: actions/github-script@v6
        with:
          script: |
            const now = new Date();
            const thirtyDaysAgo = new Date(now.getTime() - (30 * 24 * 60 * 60 * 1000));
            const sevenDaysAgo = new Date(now.getTime() - (7 * 24 * 60 * 60 * 1000));
            
            // Repository basic info
            const { data: repo } = await github.rest.repos.get({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            
            // Get recent activity
            const { data: commits } = await github.rest.repos.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              since: thirtyDaysAgo.toISOString(),
              per_page: 100
            });
            
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              since: thirtyDaysAgo.toISOString(),
              per_page: 100
            });
            
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              sort: 'created',
              direction: 'desc',
              per_page: 100
            });
            
            // Filter recent PRs
            const recentPRs = prs.filter(pr => 
              new Date(pr.created_at) >= thirtyDaysAgo
            );
            
            // Calculate metrics
            const recentCommits = commits.length;
            const recentIssues = issues.filter(issue => !issue.pull_request).length;
            const openIssues = issues.filter(issue => !issue.pull_request && issue.state === 'open').length;
            const closedIssues = issues.filter(issue => !issue.pull_request && issue.state === 'closed').length;
            const openPRs = recentPRs.filter(pr => pr.state === 'open').length;
            const mergedPRs = recentPRs.filter(pr => pr.merged_at).length;
            
            // Get unique contributors
            const contributors = new Set();
            commits.forEach(commit => {
              if (commit.author && commit.author.login) {
                contributors.add(commit.author.login);
              }
            });
            
            issues.forEach(issue => contributors.add(issue.user.login));
            recentPRs.forEach(pr => contributors.add(pr.user.login));
            
            // Calculate health scores
            const activityScore = Math.min(100, (recentCommits + recentIssues + recentPRs.length) * 2);
            const communityScore = Math.min(100, contributors.size * 10);
            const maintenanceScore = openIssues < 10 ? 100 : Math.max(0, 100 - (openIssues - 10) * 5);
            const responseScore = closedIssues > 0 ? Math.round((closedIssues / (openIssues + closedIssues)) * 100) : 50;
            
            const overallHealth = Math.round((activityScore + communityScore + maintenanceScore + responseScore) / 4);
            
            const healthReport = `## üè• Repository Health Report
            **Generated**: ${now.toISOString().split('T')[0]}
            **Overall Health Score**: ${overallHealth}/100 ${overallHealth >= 80 ? 'üü¢' : overallHealth >= 60 ? 'üü°' : 'üî¥'}
            
            ### üìä Activity Metrics (Last 30 Days)
            - **Commits**: ${recentCommits} (Score: ${activityScore}/100)
            - **New Issues**: ${recentIssues}
            - **New Pull Requests**: ${recentPRs.length}
            - **Active Contributors**: ${contributors.size} (Score: ${communityScore}/100)
            
            ### üéØ Issue Management
            - **Open Issues**: ${openIssues}
            - **Closed Issues**: ${closedIssues}
            - **Resolution Rate**: ${responseScore}% (Score: ${responseScore}/100)
            - **Maintenance Score**: ${maintenanceScore}/100
            
            ### üöÄ Pull Request Activity
            - **Open PRs**: ${openPRs}
            - **Merged PRs**: ${mergedPRs}
            - **PR Success Rate**: ${recentPRs.length > 0 ? Math.round((mergedPRs / recentPRs.length) * 100) : 0}%
            
            ### üìà Repository Stats
            - **Stars**: ${repo.stargazers_count} ‚≠ê
            - **Forks**: ${repo.forks_count} üç¥
            - **Watchers**: ${repo.subscribers_count} üëÄ
            - **Size**: ${Math.round(repo.size / 1024)} MB
            
            ### üéØ Health Recommendations
            ${overallHealth >= 80 ? 
              'üéâ **Excellent Health!** Repository is thriving with good activity and maintenance.' :
              overallHealth >= 60 ?
              '‚úÖ **Good Health** with room for improvement. Consider increasing community engagement.' :
              '‚ö†Ô∏è **Needs Attention** - Repository health could be improved with more activity and maintenance.'
            }
            
            ${activityScore < 50 ? '- Increase development activity and regular commits' : ''}
            ${communityScore < 50 ? '- Encourage more community contributions and engagement' : ''}
            ${maintenanceScore < 80 ? '- Address open issues to improve maintenance score' : ''}
            ${responseScore < 70 ? '- Improve issue response and resolution times' : ''}
            
            *Generated by advanced monitoring workflow* ü§ñ
            `;
            
            console.log(healthReport);
            
            // Store health metrics
            await github.rest.actions.setRepoVariable({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'REPO_HEALTH_SCORE',
              value: overallHealth.toString()
            });
            
            await github.rest.actions.setRepoVariable({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'ACTIVE_CONTRIBUTORS',
              value: contributors.size.toString()
            });

  monitoring-summary:
    name: üìã Monitoring Dashboard Summary
    runs-on: ubuntu-latest
    needs: [workflow-metrics, action-usage-analysis, repository-health]
    if: always()
    permissions:
      actions: read
      issues: write
    
    steps:
      - name: üìä Generate comprehensive monitoring dashboard
        uses: actions/github-script@v6
        with:
          script: |
            const jobs = [
              { name: 'workflow-metrics', result: '${{ needs.workflow-metrics.result }}' },
              { name: 'action-usage-analysis', result: '${{ needs.action-usage-analysis.result }}' },
              { name: 'repository-health', result: '${{ needs.repository-health.result }}' }
            ];
            
            const successful = jobs.filter(job => job.result === 'success').length;
            const failed = jobs.filter(job => job.result === 'failure').length;
            const total = jobs.length;
            
            const monitoringHealthy = failed === 0;
            
            // Try to get stored metrics (they might not exist on first run)
            let workflowSuccessRate = 'N/A';
            let avgDuration = 'N/A';
            let repoHealthScore = 'N/A';
            let activeContributors = 'N/A';
            
            try {
              const { data: variables } = await github.rest.actions.listRepoVariables({
                owner: context.repo.owner,
                repo: context.repo.repo
              });
              
              const workflowSuccessVar = variables.variables.find(v => v.name === 'WORKFLOW_SUCCESS_RATE');
              const avgDurationVar = variables.variables.find(v => v.name === 'WORKFLOW_AVG_DURATION');
              const repoHealthVar = variables.variables.find(v => v.name === 'REPO_HEALTH_SCORE');
              const contributorsVar = variables.variables.find(v => v.name === 'ACTIVE_CONTRIBUTORS');
              
              if (workflowSuccessVar) workflowSuccessRate = workflowSuccessVar.value + '%';
              if (avgDurationVar) avgDuration = avgDurationVar.value + ' min';
              if (repoHealthVar) repoHealthScore = repoHealthVar.value + '/100';
              if (contributorsVar) activeContributors = contributorsVar.value;
            } catch (error) {
              console.log('Could not retrieve stored metrics:', error.message);
            }
            
            const summary = `## üìä Advanced Monitoring Dashboard
            **Generated**: ${new Date().toISOString().split('T')[0]}
            **Monitoring Status**: ${monitoringHealthy ? '‚úÖ HEALTHY' : '‚ö†Ô∏è ISSUES DETECTED'}
            **Analysis Coverage**: ${successful}/${total} systems analyzed
            
            ### üéØ Key Performance Indicators
            - **Workflow Success Rate**: ${workflowSuccessRate}
            - **Average Workflow Duration**: ${avgDuration}
            - **Repository Health Score**: ${repoHealthScore}
            - **Active Contributors**: ${activeContributors}
            
            ### üìã Monitoring System Status
            ${jobs.map(job => {
              const emoji = job.result === 'success' ? '‚úÖ' : 
                           job.result === 'failure' ? '‚ùå' : 
                           job.result === 'skipped' ? '‚è∏Ô∏è' : '‚è≥';
              return `- ${emoji} **${job.name}**: ${job.result}`;
            }).join('\n')}
            
            ### üöÄ System Health
            ${monitoringHealthy ? 
              'üéâ **All monitoring systems operational!** Advanced analytics are providing comprehensive insights.' :
              '‚ö†Ô∏è **Monitoring issues detected.** Please review failed analysis systems above.'
            }
            
            ### üìà Insights & Recommendations
            - Regular monitoring provides proactive maintenance insights
            - Automated metrics help identify trends and improvement opportunities
            - Comprehensive analytics support data-driven development decisions
            
            **Advanced monitoring keeps gem-ci optimized and healthy! üöÄ**
            `;
            
            console.log(summary);
            
            // Create or update monitoring dashboard issue if running on schedule
            if (context.eventName === 'schedule') {
              const { data: issues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: 'monitoring,dashboard',
                state: 'open'
              });
              
              const existingDashboard = issues.find(issue => 
                issue.title.includes('Monitoring Dashboard')
              );
              
              const dashboardTitle = `üìä Daily Monitoring Dashboard - ${new Date().toISOString().split('T')[0]}`;
              
              if (existingDashboard) {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existingDashboard.number,
                  title: dashboardTitle,
                  body: summary
                });
                console.log(`Updated monitoring dashboard issue #${existingDashboard.number}`);
              } else {
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: dashboardTitle,
                  body: summary,
                  labels: ['monitoring', 'dashboard', 'automated']
                });
                console.log('Created new monitoring dashboard issue');
              }
            }
